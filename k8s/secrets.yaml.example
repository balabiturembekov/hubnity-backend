# Hubnity Backend — Secrets Template (base64-encoded)
#
# 1. Copy to secrets.yaml: cp secrets.yaml.example secrets.yaml
# 2. Fill in real values (base64-encode if using data:)
# 3. NEVER commit secrets.yaml to git
#
# Alternative: create via kubectl (recommended for production):
#   kubectl create secret generic hubnity-secrets -n hubnity \
#     --from-literal=DATABASE_URL='postgresql://...' \
#     --from-literal=JWT_SECRET='...' \
#     --from-literal=REDIS_PASSWORD='' \
#     --from-literal=S3_ACCESS_KEY_ID='...' \
#     --from-literal=S3_SECRET_ACCESS_KEY='...' \
#     --dry-run=client -o yaml > secrets.yaml
#
apiVersion: v1
kind: Secret
metadata:
  name: hubnity-secrets
  namespace: hubnity
type: Opaque
#
# Option A: stringData (plain text, K8s encodes automatically) — easier for templates
stringData:
  DATABASE_URL: "postgresql://postgres:CHANGE_ME@hubnity-postgres:5432/timetracker?schema=public"
  JWT_SECRET: "CHANGE_ME_STRONG_SECRET_MIN_32_CHARS"
  # Redis (app uses REDIS_HOST, REDIS_PORT, REDIS_PASSWORD from ConfigMap + Secret)
  REDIS_PASSWORD: ""
  # S3 (optional — uncomment when using S3-compatible storage)
  # S3_ACCESS_KEY_ID: "CHANGE_ME"
  # S3_SECRET_ACCESS_KEY: "CHANGE_ME"
#
# Option B: data (base64-encoded) — use when storing in version control (encrypted)
# data:
#   DATABASE_URL: <echo -n "postgresql://..." | base64>
#   JWT_SECRET: <echo -n "your-secret" | base64>
#   REDIS_URL: <echo -n "redis://..." | base64>
#   S3_ACCESS_KEY_ID: <echo -n "..." | base64>
#   S3_SECRET_ACCESS_KEY: <echo -n "..." | base64>
