services:
  postgres:
    # Port mapping removed - PostgreSQL only accessible within Docker network
    # ports:
    #   - "${POSTGRES_PORT:-5432}:5432"
    # Production PostgreSQL optimizations
    command: >
      postgres
      -c shared_buffers=512MB
      -c max_connections=300
      -c effective_cache_size=2GB
      -c maintenance_work_mem=128MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=8MB
      -c min_wal_size=2GB
      -c max_wal_size=8GB
      -c log_statement=all
      -c log_duration=on
      -c log_line_prefix='%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  redis:
    # Production Redis optimizations (add --requirepass when REDIS_PASSWORD is set)
    command:
      - redis-server
      - --maxmemory
      - "512mb"
      - --maxmemory-policy
      - allkeys-lru
      - --appendonly
      - "yes"
      - --appendfsync
      - "everysec"
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  backend:
    # For deploy.sh pull: use pre-built image from registry
    image: ${HUBNITY_BACKEND_IMAGE:-ghcr.io/balabiturembekov/hubnity-backend:latest}
    # Production backend settings
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        order: start-first
        failure_action: rollback
        delay: 10s
      rollback_config:
        parallelism: 1
        order: stop-first
      resources:
        limits:
          cpus: "2"
          memory: 2G
        reservations:
          cpus: "1"
          memory: 512M
